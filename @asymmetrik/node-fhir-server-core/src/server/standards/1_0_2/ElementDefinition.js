const Element = require('./Element');
const Base64BinaryScalar = require('./scalars/Base64Binary.scalar');
const InstantScalar = require('./scalars/Instant.scalar');
const UriScalar = require('./scalars/Uri.scalar');
const DateScalar = require('./scalars/Date.scalar');
const DateTimeScalar = require('./scalars/DateTime.scalar');
const TimeScalar = require('./scalars/Time.scalar');
const CodeScalar = require('./scalars/Code.scalar');
const OidScalar = require('./scalars/Oid.scalar');
const IdScalar = require('./scalars/Id.scalar');
const UnsignedIntScalar = require('./scalars/UnsignedInt.scalar');
const PositiveIntScalar = require('./scalars/PositiveInt.scalar');

class ElementDefinition extends Element {
	constructor(opt) {
		super(opt);
		this.__resourceType = 'ElementDefinition';
		Object.assign(this, opt);
	}

	// This is a ElementDefinition resource
	static get __resourceType() {
		return 'ElementDefinition';
	}

	// The path identifies the element and is expressed as a \'.\'-separated list of ancestor elements, beginning with the name of the resource or extension.
	get path() {
		return this.__path;
	}

	set path(new_value) {
		this.__path = new_value;
	}

	// Codes that define how this element is represented in instances, when the deviation varies from the normal case.
	get representation() {
		return this.__representation;
	}

	set representation(new_value) {
		this.__representation = Array.isArray(new_value) ? new_value : [new_value];
	}

	// The name of this element definition (to refer to it from other element definitions using ElementDefinition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
	get name() {
		return this.__name;
	}

	set name(new_value) {
		this.__name = new_value;
	}

	// The text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
	get label() {
		return this.__label;
	}

	set label(new_value) {
		this.__label = new_value;
	}

	// A code that provides the meaning for the element according to a particular terminology.
	get code() {
		return this.__code;
	}

	set code(new_value) {
		const Coding = require('./Coding');
		this.__code = Array.isArray(new_value) ? new_value.map(val => new Coding(val)) : [new Coding(new_value)];
	}

	// Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
	get slicing() {
		return this.__slicing;
	}

	set slicing(new_value) {
		const ElementDefinitionSlicing = require('./ElementDefinitionSlicing');
		this.__slicing = new ElementDefinitionSlicing(new_value);
	}

	// A concise description of what this element means (e.g. for use in autogenerated summaries).
	get short() {
		return this.__short;
	}

	set short(new_value) {
		this.__short = new_value;
	}

	// Provides a complete explanation of the meaning of the data element for human readability.  For the case of elements derived from existing elements (e.g. constraints), the definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
	get definition() {
		return this.__definition;
	}

	set definition(new_value) {
		this.__definition = new_value;
	}

	// Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc.
	get comments() {
		return this.__comments;
	}

	set comments(new_value) {
		this.__comments = new_value;
	}

	// This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
	get requirements() {
		return this.__requirements;
	}

	set requirements(new_value) {
		this.__requirements = new_value;
	}

	// Identifies additional names by which this element might also be known.
	get alias() {
		return this.__alias;
	}

	set alias(new_value) {
		this.__alias = Array.isArray(new_value) ? new_value : [new_value];
	}

	// The minimum number of times this element SHALL appear in the instance.
	get min() {
		return this.__min;
	}

	set min(new_value) {
		this.__min = new_value;
	}

	// The maximum number of times this element is permitted to appear in the instance.
	get max() {
		return this.__max;
	}

	set max(new_value) {
		this.__max = new_value;
	}

	// Information about the base definition of the element, provided to make it unncessary for tools to trace the deviation of the element through the derived and related profiles. This information is only provided where the element definition represents a constraint on another element definition, and must be present if there is a base element definition.
	get base() {
		return this.__base;
	}

	set base(new_value) {
		const ElementDefinitionBase = require('./ElementDefinitionBase');
		this.__base = new ElementDefinitionBase(new_value);
	}

	// The data type or resource that the value of this element is permitted to be.
	get type() {
		return this.__type;
	}

	set type(new_value) {
		const ElementDefinitionType = require('./ElementDefinitionType');
		this.__type = Array.isArray(new_value)
			? new_value.map(val => new ElementDefinitionType(val))
			: [new ElementDefinitionType(new_value)];
	}

	// Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
	get nameReference() {
		return this.__nameReference;
	}

	set nameReference(new_value) {
		this.__nameReference = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueBoolean() {
		return this.__defaultValueBoolean;
	}

	set defaultValueBoolean(new_value) {
		this.__defaultValueBoolean = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueInteger() {
		return this.__defaultValueInteger;
	}

	set defaultValueInteger(new_value) {
		this.__defaultValueInteger = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDecimal() {
		return this.__defaultValueDecimal;
	}

	set defaultValueDecimal(new_value) {
		this.__defaultValueDecimal = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueBase64Binary() {
		return this.__defaultValueBase64Binary;
	}

	set defaultValueBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueBase64Binary`);
		}
		this.__defaultValueBase64Binary = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueInstant() {
		return this.__defaultValueInstant;
	}

	set defaultValueInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueInstant`);
		}
		this.__defaultValueInstant = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueString() {
		return this.__defaultValueString;
	}

	set defaultValueString(new_value) {
		this.__defaultValueString = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueUri() {
		return this.__defaultValueUri;
	}

	set defaultValueUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueUri`);
		}
		this.__defaultValueUri = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDate() {
		return this.__defaultValueDate;
	}

	set defaultValueDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueDate`);
		}
		this.__defaultValueDate = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDateTime() {
		return this.__defaultValueDateTime;
	}

	set defaultValueDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueDateTime`);
		}
		this.__defaultValueDateTime = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueTime() {
		return this.__defaultValueTime;
	}

	set defaultValueTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueTime`);
		}
		this.__defaultValueTime = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueCode() {
		return this.__defaultValueCode;
	}

	set defaultValueCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueCode`);
		}
		this.__defaultValueCode = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueOid() {
		return this.__defaultValueOid;
	}

	set defaultValueOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueOid`);
		}
		this.__defaultValueOid = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueId() {
		return this.__defaultValueId;
	}

	set defaultValueId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueId`);
		}
		this.__defaultValueId = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueUnsignedInt() {
		return this.__defaultValueUnsignedInt;
	}

	set defaultValueUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueUnsignedInt`);
		}
		this.__defaultValueUnsignedInt = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValuePositiveInt() {
		return this.__defaultValuePositiveInt;
	}

	set defaultValuePositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValuePositiveInt`);
		}
		this.__defaultValuePositiveInt = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueMarkdown() {
		return this.__defaultValueMarkdown;
	}

	set defaultValueMarkdown(new_value) {
		this.__defaultValueMarkdown = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueAnnotation() {
		return this.__defaultValueAnnotation;
	}

	set defaultValueAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__defaultValueAnnotation = new Annotation(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueAttachment() {
		return this.__defaultValueAttachment;
	}

	set defaultValueAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__defaultValueAttachment = new Attachment(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueIdentifier() {
		return this.__defaultValueIdentifier;
	}

	set defaultValueIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__defaultValueIdentifier = new Identifier(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueCodeableConcept() {
		return this.__defaultValueCodeableConcept;
	}

	set defaultValueCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__defaultValueCodeableConcept = new CodeableConcept(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueCoding() {
		return this.__defaultValueCoding;
	}

	set defaultValueCoding(new_value) {
		const Coding = require('./Coding');
		this.__defaultValueCoding = new Coding(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueQuantity() {
		return this.__defaultValueQuantity;
	}

	set defaultValueQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__defaultValueQuantity = new Quantity(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueRange() {
		return this.__defaultValueRange;
	}

	set defaultValueRange(new_value) {
		const Range = require('./Range');
		this.__defaultValueRange = new Range(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValuePeriod() {
		return this.__defaultValuePeriod;
	}

	set defaultValuePeriod(new_value) {
		const Period = require('./Period');
		this.__defaultValuePeriod = new Period(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueRatio() {
		return this.__defaultValueRatio;
	}

	set defaultValueRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__defaultValueRatio = new Ratio(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueSampledData() {
		return this.__defaultValueSampledData;
	}

	set defaultValueSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__defaultValueSampledData = new SampledData(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueSignature() {
		return this.__defaultValueSignature;
	}

	set defaultValueSignature(new_value) {
		const Signature = require('./Signature');
		this.__defaultValueSignature = new Signature(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueHumanName() {
		return this.__defaultValueHumanName;
	}

	set defaultValueHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__defaultValueHumanName = new HumanName(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueAddress() {
		return this.__defaultValueAddress;
	}

	set defaultValueAddress(new_value) {
		const Address = require('./Address');
		this.__defaultValueAddress = new Address(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueContactPoint() {
		return this.__defaultValueContactPoint;
	}

	set defaultValueContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__defaultValueContactPoint = new ContactPoint(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueTiming() {
		return this.__defaultValueTiming;
	}

	set defaultValueTiming(new_value) {
		const Timing = require('./Timing');
		this.__defaultValueTiming = new Timing(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueReference() {
		return this.__defaultValueReference;
	}

	set defaultValueReference(new_value) {
		const Reference = require('./Reference');
		this.__defaultValueReference = new Reference(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueMeta() {
		return this.__defaultValueMeta;
	}

	set defaultValueMeta(new_value) {
		const Meta = require('./Meta');
		this.__defaultValueMeta = new Meta(new_value);
	}

	// The Implicit meaning that is to be understood when this element is missing (e.g. \'when this element is missing, the period is ongoing\'.
	get meaningWhenMissing() {
		return this.__meaningWhenMissing;
	}

	set meaningWhenMissing(new_value) {
		this.__meaningWhenMissing = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedBoolean() {
		return this.__fixedBoolean;
	}

	set fixedBoolean(new_value) {
		this.__fixedBoolean = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedInteger() {
		return this.__fixedInteger;
	}

	set fixedInteger(new_value) {
		this.__fixedInteger = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDecimal() {
		return this.__fixedDecimal;
	}

	set fixedDecimal(new_value) {
		this.__fixedDecimal = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedBase64Binary() {
		return this.__fixedBase64Binary;
	}

	set fixedBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedBase64Binary`);
		}
		this.__fixedBase64Binary = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedInstant() {
		return this.__fixedInstant;
	}

	set fixedInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedInstant`);
		}
		this.__fixedInstant = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedString() {
		return this.__fixedString;
	}

	set fixedString(new_value) {
		this.__fixedString = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedUri() {
		return this.__fixedUri;
	}

	set fixedUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedUri`);
		}
		this.__fixedUri = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDate() {
		return this.__fixedDate;
	}

	set fixedDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedDate`);
		}
		this.__fixedDate = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDateTime() {
		return this.__fixedDateTime;
	}

	set fixedDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedDateTime`);
		}
		this.__fixedDateTime = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedTime() {
		return this.__fixedTime;
	}

	set fixedTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedTime`);
		}
		this.__fixedTime = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedCode() {
		return this.__fixedCode;
	}

	set fixedCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedCode`);
		}
		this.__fixedCode = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedOid() {
		return this.__fixedOid;
	}

	set fixedOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedOid`);
		}
		this.__fixedOid = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedId() {
		return this.__fixedId;
	}

	set fixedId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedId`);
		}
		this.__fixedId = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedUnsignedInt() {
		return this.__fixedUnsignedInt;
	}

	set fixedUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedUnsignedInt`);
		}
		this.__fixedUnsignedInt = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedPositiveInt() {
		return this.__fixedPositiveInt;
	}

	set fixedPositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedPositiveInt`);
		}
		this.__fixedPositiveInt = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedMarkdown() {
		return this.__fixedMarkdown;
	}

	set fixedMarkdown(new_value) {
		this.__fixedMarkdown = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedAnnotation() {
		return this.__fixedAnnotation;
	}

	set fixedAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__fixedAnnotation = new Annotation(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedAttachment() {
		return this.__fixedAttachment;
	}

	set fixedAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__fixedAttachment = new Attachment(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedIdentifier() {
		return this.__fixedIdentifier;
	}

	set fixedIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__fixedIdentifier = new Identifier(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedCodeableConcept() {
		return this.__fixedCodeableConcept;
	}

	set fixedCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__fixedCodeableConcept = new CodeableConcept(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedCoding() {
		return this.__fixedCoding;
	}

	set fixedCoding(new_value) {
		const Coding = require('./Coding');
		this.__fixedCoding = new Coding(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedQuantity() {
		return this.__fixedQuantity;
	}

	set fixedQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__fixedQuantity = new Quantity(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedRange() {
		return this.__fixedRange;
	}

	set fixedRange(new_value) {
		const Range = require('./Range');
		this.__fixedRange = new Range(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedPeriod() {
		return this.__fixedPeriod;
	}

	set fixedPeriod(new_value) {
		const Period = require('./Period');
		this.__fixedPeriod = new Period(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedRatio() {
		return this.__fixedRatio;
	}

	set fixedRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__fixedRatio = new Ratio(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedSampledData() {
		return this.__fixedSampledData;
	}

	set fixedSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__fixedSampledData = new SampledData(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedSignature() {
		return this.__fixedSignature;
	}

	set fixedSignature(new_value) {
		const Signature = require('./Signature');
		this.__fixedSignature = new Signature(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedHumanName() {
		return this.__fixedHumanName;
	}

	set fixedHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__fixedHumanName = new HumanName(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedAddress() {
		return this.__fixedAddress;
	}

	set fixedAddress(new_value) {
		const Address = require('./Address');
		this.__fixedAddress = new Address(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedContactPoint() {
		return this.__fixedContactPoint;
	}

	set fixedContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__fixedContactPoint = new ContactPoint(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedTiming() {
		return this.__fixedTiming;
	}

	set fixedTiming(new_value) {
		const Timing = require('./Timing');
		this.__fixedTiming = new Timing(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedReference() {
		return this.__fixedReference;
	}

	set fixedReference(new_value) {
		const Reference = require('./Reference');
		this.__fixedReference = new Reference(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedMeta() {
		return this.__fixedMeta;
	}

	set fixedMeta(new_value) {
		const Meta = require('./Meta');
		this.__fixedMeta = new Meta(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternBoolean() {
		return this.__patternBoolean;
	}

	set patternBoolean(new_value) {
		this.__patternBoolean = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternInteger() {
		return this.__patternInteger;
	}

	set patternInteger(new_value) {
		this.__patternInteger = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDecimal() {
		return this.__patternDecimal;
	}

	set patternDecimal(new_value) {
		this.__patternDecimal = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternBase64Binary() {
		return this.__patternBase64Binary;
	}

	set patternBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternBase64Binary`);
		}
		this.__patternBase64Binary = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternInstant() {
		return this.__patternInstant;
	}

	set patternInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternInstant`);
		}
		this.__patternInstant = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternString() {
		return this.__patternString;
	}

	set patternString(new_value) {
		this.__patternString = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternUri() {
		return this.__patternUri;
	}

	set patternUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternUri`);
		}
		this.__patternUri = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDate() {
		return this.__patternDate;
	}

	set patternDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternDate`);
		}
		this.__patternDate = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDateTime() {
		return this.__patternDateTime;
	}

	set patternDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternDateTime`);
		}
		this.__patternDateTime = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternTime() {
		return this.__patternTime;
	}

	set patternTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternTime`);
		}
		this.__patternTime = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternCode() {
		return this.__patternCode;
	}

	set patternCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternCode`);
		}
		this.__patternCode = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternOid() {
		return this.__patternOid;
	}

	set patternOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternOid`);
		}
		this.__patternOid = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternId() {
		return this.__patternId;
	}

	set patternId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternId`);
		}
		this.__patternId = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternUnsignedInt() {
		return this.__patternUnsignedInt;
	}

	set patternUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternUnsignedInt`);
		}
		this.__patternUnsignedInt = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternPositiveInt() {
		return this.__patternPositiveInt;
	}

	set patternPositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternPositiveInt`);
		}
		this.__patternPositiveInt = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternMarkdown() {
		return this.__patternMarkdown;
	}

	set patternMarkdown(new_value) {
		this.__patternMarkdown = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternAnnotation() {
		return this.__patternAnnotation;
	}

	set patternAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__patternAnnotation = new Annotation(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternAttachment() {
		return this.__patternAttachment;
	}

	set patternAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__patternAttachment = new Attachment(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternIdentifier() {
		return this.__patternIdentifier;
	}

	set patternIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__patternIdentifier = new Identifier(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternCodeableConcept() {
		return this.__patternCodeableConcept;
	}

	set patternCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__patternCodeableConcept = new CodeableConcept(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternCoding() {
		return this.__patternCoding;
	}

	set patternCoding(new_value) {
		const Coding = require('./Coding');
		this.__patternCoding = new Coding(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternQuantity() {
		return this.__patternQuantity;
	}

	set patternQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__patternQuantity = new Quantity(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternRange() {
		return this.__patternRange;
	}

	set patternRange(new_value) {
		const Range = require('./Range');
		this.__patternRange = new Range(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternPeriod() {
		return this.__patternPeriod;
	}

	set patternPeriod(new_value) {
		const Period = require('./Period');
		this.__patternPeriod = new Period(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternRatio() {
		return this.__patternRatio;
	}

	set patternRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__patternRatio = new Ratio(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternSampledData() {
		return this.__patternSampledData;
	}

	set patternSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__patternSampledData = new SampledData(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternSignature() {
		return this.__patternSignature;
	}

	set patternSignature(new_value) {
		const Signature = require('./Signature');
		this.__patternSignature = new Signature(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternHumanName() {
		return this.__patternHumanName;
	}

	set patternHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__patternHumanName = new HumanName(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternAddress() {
		return this.__patternAddress;
	}

	set patternAddress(new_value) {
		const Address = require('./Address');
		this.__patternAddress = new Address(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternContactPoint() {
		return this.__patternContactPoint;
	}

	set patternContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__patternContactPoint = new ContactPoint(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternTiming() {
		return this.__patternTiming;
	}

	set patternTiming(new_value) {
		const Timing = require('./Timing');
		this.__patternTiming = new Timing(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternReference() {
		return this.__patternReference;
	}

	set patternReference(new_value) {
		const Reference = require('./Reference');
		this.__patternReference = new Reference(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternMeta() {
		return this.__patternMeta;
	}

	set patternMeta(new_value) {
		const Meta = require('./Meta');
		this.__patternMeta = new Meta(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleBoolean() {
		return this.__exampleBoolean;
	}

	set exampleBoolean(new_value) {
		this.__exampleBoolean = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleInteger() {
		return this.__exampleInteger;
	}

	set exampleInteger(new_value) {
		this.__exampleInteger = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleDecimal() {
		return this.__exampleDecimal;
	}

	set exampleDecimal(new_value) {
		this.__exampleDecimal = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleBase64Binary() {
		return this.__exampleBase64Binary;
	}

	set exampleBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleBase64Binary`);
		}
		this.__exampleBase64Binary = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleInstant() {
		return this.__exampleInstant;
	}

	set exampleInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleInstant`);
		}
		this.__exampleInstant = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleString() {
		return this.__exampleString;
	}

	set exampleString(new_value) {
		this.__exampleString = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleUri() {
		return this.__exampleUri;
	}

	set exampleUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleUri`);
		}
		this.__exampleUri = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleDate() {
		return this.__exampleDate;
	}

	set exampleDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleDate`);
		}
		this.__exampleDate = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleDateTime() {
		return this.__exampleDateTime;
	}

	set exampleDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleDateTime`);
		}
		this.__exampleDateTime = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleTime() {
		return this.__exampleTime;
	}

	set exampleTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleTime`);
		}
		this.__exampleTime = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleCode() {
		return this.__exampleCode;
	}

	set exampleCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleCode`);
		}
		this.__exampleCode = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleOid() {
		return this.__exampleOid;
	}

	set exampleOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleOid`);
		}
		this.__exampleOid = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleId() {
		return this.__exampleId;
	}

	set exampleId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleId`);
		}
		this.__exampleId = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleUnsignedInt() {
		return this.__exampleUnsignedInt;
	}

	set exampleUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field exampleUnsignedInt`);
		}
		this.__exampleUnsignedInt = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get examplePositiveInt() {
		return this.__examplePositiveInt;
	}

	set examplePositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field examplePositiveInt`);
		}
		this.__examplePositiveInt = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleMarkdown() {
		return this.__exampleMarkdown;
	}

	set exampleMarkdown(new_value) {
		this.__exampleMarkdown = new_value;
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleAnnotation() {
		return this.__exampleAnnotation;
	}

	set exampleAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__exampleAnnotation = new Annotation(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleAttachment() {
		return this.__exampleAttachment;
	}

	set exampleAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__exampleAttachment = new Attachment(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleIdentifier() {
		return this.__exampleIdentifier;
	}

	set exampleIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__exampleIdentifier = new Identifier(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleCodeableConcept() {
		return this.__exampleCodeableConcept;
	}

	set exampleCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__exampleCodeableConcept = new CodeableConcept(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleCoding() {
		return this.__exampleCoding;
	}

	set exampleCoding(new_value) {
		const Coding = require('./Coding');
		this.__exampleCoding = new Coding(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleQuantity() {
		return this.__exampleQuantity;
	}

	set exampleQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__exampleQuantity = new Quantity(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleRange() {
		return this.__exampleRange;
	}

	set exampleRange(new_value) {
		const Range = require('./Range');
		this.__exampleRange = new Range(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get examplePeriod() {
		return this.__examplePeriod;
	}

	set examplePeriod(new_value) {
		const Period = require('./Period');
		this.__examplePeriod = new Period(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleRatio() {
		return this.__exampleRatio;
	}

	set exampleRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__exampleRatio = new Ratio(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleSampledData() {
		return this.__exampleSampledData;
	}

	set exampleSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__exampleSampledData = new SampledData(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleSignature() {
		return this.__exampleSignature;
	}

	set exampleSignature(new_value) {
		const Signature = require('./Signature');
		this.__exampleSignature = new Signature(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleHumanName() {
		return this.__exampleHumanName;
	}

	set exampleHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__exampleHumanName = new HumanName(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleAddress() {
		return this.__exampleAddress;
	}

	set exampleAddress(new_value) {
		const Address = require('./Address');
		this.__exampleAddress = new Address(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleContactPoint() {
		return this.__exampleContactPoint;
	}

	set exampleContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__exampleContactPoint = new ContactPoint(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleTiming() {
		return this.__exampleTiming;
	}

	set exampleTiming(new_value) {
		const Timing = require('./Timing');
		this.__exampleTiming = new Timing(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleReference() {
		return this.__exampleReference;
	}

	set exampleReference(new_value) {
		const Reference = require('./Reference');
		this.__exampleReference = new Reference(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be captured.
	get exampleMeta() {
		return this.__exampleMeta;
	}

	set exampleMeta(new_value) {
		const Meta = require('./Meta');
		this.__exampleMeta = new Meta(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueBoolean() {
		return this.__minValueBoolean;
	}

	set minValueBoolean(new_value) {
		this.__minValueBoolean = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueInteger() {
		return this.__minValueInteger;
	}

	set minValueInteger(new_value) {
		this.__minValueInteger = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueDecimal() {
		return this.__minValueDecimal;
	}

	set minValueDecimal(new_value) {
		this.__minValueDecimal = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueBase64Binary() {
		return this.__minValueBase64Binary;
	}

	set minValueBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueBase64Binary`);
		}
		this.__minValueBase64Binary = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueInstant() {
		return this.__minValueInstant;
	}

	set minValueInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueInstant`);
		}
		this.__minValueInstant = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueString() {
		return this.__minValueString;
	}

	set minValueString(new_value) {
		this.__minValueString = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueUri() {
		return this.__minValueUri;
	}

	set minValueUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueUri`);
		}
		this.__minValueUri = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueDate() {
		return this.__minValueDate;
	}

	set minValueDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueDate`);
		}
		this.__minValueDate = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueDateTime() {
		return this.__minValueDateTime;
	}

	set minValueDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueDateTime`);
		}
		this.__minValueDateTime = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueTime() {
		return this.__minValueTime;
	}

	set minValueTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueTime`);
		}
		this.__minValueTime = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueCode() {
		return this.__minValueCode;
	}

	set minValueCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueCode`);
		}
		this.__minValueCode = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueOid() {
		return this.__minValueOid;
	}

	set minValueOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueOid`);
		}
		this.__minValueOid = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueId() {
		return this.__minValueId;
	}

	set minValueId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueId`);
		}
		this.__minValueId = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueUnsignedInt() {
		return this.__minValueUnsignedInt;
	}

	set minValueUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueUnsignedInt`);
		}
		this.__minValueUnsignedInt = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValuePositiveInt() {
		return this.__minValuePositiveInt;
	}

	set minValuePositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValuePositiveInt`);
		}
		this.__minValuePositiveInt = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueMarkdown() {
		return this.__minValueMarkdown;
	}

	set minValueMarkdown(new_value) {
		this.__minValueMarkdown = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueAnnotation() {
		return this.__minValueAnnotation;
	}

	set minValueAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__minValueAnnotation = new Annotation(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueAttachment() {
		return this.__minValueAttachment;
	}

	set minValueAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__minValueAttachment = new Attachment(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueIdentifier() {
		return this.__minValueIdentifier;
	}

	set minValueIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__minValueIdentifier = new Identifier(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueCodeableConcept() {
		return this.__minValueCodeableConcept;
	}

	set minValueCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__minValueCodeableConcept = new CodeableConcept(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueCoding() {
		return this.__minValueCoding;
	}

	set minValueCoding(new_value) {
		const Coding = require('./Coding');
		this.__minValueCoding = new Coding(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueQuantity() {
		return this.__minValueQuantity;
	}

	set minValueQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__minValueQuantity = new Quantity(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueRange() {
		return this.__minValueRange;
	}

	set minValueRange(new_value) {
		const Range = require('./Range');
		this.__minValueRange = new Range(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValuePeriod() {
		return this.__minValuePeriod;
	}

	set minValuePeriod(new_value) {
		const Period = require('./Period');
		this.__minValuePeriod = new Period(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueRatio() {
		return this.__minValueRatio;
	}

	set minValueRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__minValueRatio = new Ratio(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueSampledData() {
		return this.__minValueSampledData;
	}

	set minValueSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__minValueSampledData = new SampledData(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueSignature() {
		return this.__minValueSignature;
	}

	set minValueSignature(new_value) {
		const Signature = require('./Signature');
		this.__minValueSignature = new Signature(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueHumanName() {
		return this.__minValueHumanName;
	}

	set minValueHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__minValueHumanName = new HumanName(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueAddress() {
		return this.__minValueAddress;
	}

	set minValueAddress(new_value) {
		const Address = require('./Address');
		this.__minValueAddress = new Address(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueContactPoint() {
		return this.__minValueContactPoint;
	}

	set minValueContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__minValueContactPoint = new ContactPoint(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueTiming() {
		return this.__minValueTiming;
	}

	set minValueTiming(new_value) {
		const Timing = require('./Timing');
		this.__minValueTiming = new Timing(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueReference() {
		return this.__minValueReference;
	}

	set minValueReference(new_value) {
		const Reference = require('./Reference');
		this.__minValueReference = new Reference(new_value);
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueMeta() {
		return this.__minValueMeta;
	}

	set minValueMeta(new_value) {
		const Meta = require('./Meta');
		this.__minValueMeta = new Meta(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueBoolean() {
		return this.__maxValueBoolean;
	}

	set maxValueBoolean(new_value) {
		this.__maxValueBoolean = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueInteger() {
		return this.__maxValueInteger;
	}

	set maxValueInteger(new_value) {
		this.__maxValueInteger = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueDecimal() {
		return this.__maxValueDecimal;
	}

	set maxValueDecimal(new_value) {
		this.__maxValueDecimal = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueBase64Binary() {
		return this.__maxValueBase64Binary;
	}

	set maxValueBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueBase64Binary`);
		}
		this.__maxValueBase64Binary = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueInstant() {
		return this.__maxValueInstant;
	}

	set maxValueInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueInstant`);
		}
		this.__maxValueInstant = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueString() {
		return this.__maxValueString;
	}

	set maxValueString(new_value) {
		this.__maxValueString = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueUri() {
		return this.__maxValueUri;
	}

	set maxValueUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueUri`);
		}
		this.__maxValueUri = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueDate() {
		return this.__maxValueDate;
	}

	set maxValueDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueDate`);
		}
		this.__maxValueDate = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueDateTime() {
		return this.__maxValueDateTime;
	}

	set maxValueDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueDateTime`);
		}
		this.__maxValueDateTime = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueTime() {
		return this.__maxValueTime;
	}

	set maxValueTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueTime`);
		}
		this.__maxValueTime = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueCode() {
		return this.__maxValueCode;
	}

	set maxValueCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueCode`);
		}
		this.__maxValueCode = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueOid() {
		return this.__maxValueOid;
	}

	set maxValueOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueOid`);
		}
		this.__maxValueOid = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueId() {
		return this.__maxValueId;
	}

	set maxValueId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueId`);
		}
		this.__maxValueId = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueUnsignedInt() {
		return this.__maxValueUnsignedInt;
	}

	set maxValueUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueUnsignedInt`);
		}
		this.__maxValueUnsignedInt = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValuePositiveInt() {
		return this.__maxValuePositiveInt;
	}

	set maxValuePositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValuePositiveInt`);
		}
		this.__maxValuePositiveInt = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueMarkdown() {
		return this.__maxValueMarkdown;
	}

	set maxValueMarkdown(new_value) {
		this.__maxValueMarkdown = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueAnnotation() {
		return this.__maxValueAnnotation;
	}

	set maxValueAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__maxValueAnnotation = new Annotation(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueAttachment() {
		return this.__maxValueAttachment;
	}

	set maxValueAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__maxValueAttachment = new Attachment(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueIdentifier() {
		return this.__maxValueIdentifier;
	}

	set maxValueIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__maxValueIdentifier = new Identifier(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueCodeableConcept() {
		return this.__maxValueCodeableConcept;
	}

	set maxValueCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__maxValueCodeableConcept = new CodeableConcept(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueCoding() {
		return this.__maxValueCoding;
	}

	set maxValueCoding(new_value) {
		const Coding = require('./Coding');
		this.__maxValueCoding = new Coding(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueQuantity() {
		return this.__maxValueQuantity;
	}

	set maxValueQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__maxValueQuantity = new Quantity(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueRange() {
		return this.__maxValueRange;
	}

	set maxValueRange(new_value) {
		const Range = require('./Range');
		this.__maxValueRange = new Range(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValuePeriod() {
		return this.__maxValuePeriod;
	}

	set maxValuePeriod(new_value) {
		const Period = require('./Period');
		this.__maxValuePeriod = new Period(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueRatio() {
		return this.__maxValueRatio;
	}

	set maxValueRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__maxValueRatio = new Ratio(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueSampledData() {
		return this.__maxValueSampledData;
	}

	set maxValueSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__maxValueSampledData = new SampledData(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueSignature() {
		return this.__maxValueSignature;
	}

	set maxValueSignature(new_value) {
		const Signature = require('./Signature');
		this.__maxValueSignature = new Signature(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueHumanName() {
		return this.__maxValueHumanName;
	}

	set maxValueHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__maxValueHumanName = new HumanName(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueAddress() {
		return this.__maxValueAddress;
	}

	set maxValueAddress(new_value) {
		const Address = require('./Address');
		this.__maxValueAddress = new Address(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueContactPoint() {
		return this.__maxValueContactPoint;
	}

	set maxValueContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__maxValueContactPoint = new ContactPoint(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueTiming() {
		return this.__maxValueTiming;
	}

	set maxValueTiming(new_value) {
		const Timing = require('./Timing');
		this.__maxValueTiming = new Timing(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueReference() {
		return this.__maxValueReference;
	}

	set maxValueReference(new_value) {
		const Reference = require('./Reference');
		this.__maxValueReference = new Reference(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueMeta() {
		return this.__maxValueMeta;
	}

	set maxValueMeta(new_value) {
		const Meta = require('./Meta');
		this.__maxValueMeta = new Meta(new_value);
	}

	// Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
	get maxLength() {
		return this.__maxLength;
	}

	set maxLength(new_value) {
		this.__maxLength = new_value;
	}

	// A reference to an invariant that may make additional statements about the cardinality or value in the instance.
	get condition() {
		return this.__condition;
	}

	set condition(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field condition`);
		}
		this.__condition = Array.isArray(new_value) ? new_value : [new_value];
	}

	// Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
	get constraint() {
		return this.__constraint;
	}

	set constraint(new_value) {
		const ElementDefinitionConstraint = require('./ElementDefinitionConstraint');
		this.__constraint = Array.isArray(new_value)
			? new_value.map(val => new ElementDefinitionConstraint(val))
			: [new ElementDefinitionConstraint(new_value)];
	}

	// If true, implementations that produce or consume resources SHALL provide \'support\' for the element in some meaningful way.  If false, the element may be ignored and not supported.
	get mustSupport() {
		return this.__mustSupport;
	}

	set mustSupport(new_value) {
		this.__mustSupport = new_value;
	}

	// If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
	get isModifier() {
		return this.__isModifier;
	}

	set isModifier(new_value) {
		this.__isModifier = new_value;
	}

	// Whether the element should be included if a client requests a search with the parameter _summary=true.
	get isSummary() {
		return this.__isSummary;
	}

	set isSummary(new_value) {
		this.__isSummary = new_value;
	}

	// Binds to a value set if this element is coded (code, Coding, CodeableConcept).
	get binding() {
		return this.__binding;
	}

	set binding(new_value) {
		const ElementDefinitionBinding = require('./ElementDefinitionBinding');
		this.__binding = new ElementDefinitionBinding(new_value);
	}

	// Identifies a concept from an external specification that roughly corresponds to this element.
	get mapping() {
		return this.__mapping;
	}

	set mapping(new_value) {
		const ElementDefinitionMapping = require('./ElementDefinitionMapping');
		this.__mapping = Array.isArray(new_value)
			? new_value.map(val => new ElementDefinitionMapping(val))
			: [new ElementDefinitionMapping(new_value)];
	}

	toJSON() {
		return Object.assign(super.toJSON(), {
			path: this.__path,
			representation: this.__representation,
			name: this.__name,
			label: this.__label,
			code: this.__code && this.__code.map(v => v.toJSON()),
			slicing: this.__slicing && this.__slicing.toJSON(),
			short: this.__short,
			definition: this.__definition,
			comments: this.__comments,
			requirements: this.__requirements,
			alias: this.__alias,
			min: this.__min,
			max: this.__max,
			base: this.__base && this.__base.toJSON(),
			type: this.__type && this.__type.map(v => v.toJSON()),
			nameReference: this.__nameReference,
			defaultValueBoolean: this.__defaultValueBoolean,
			defaultValueInteger: this.__defaultValueInteger,
			defaultValueDecimal: this.__defaultValueDecimal,
			defaultValueBase64Binary: this.__defaultValueBase64Binary,
			defaultValueInstant: this.__defaultValueInstant,
			defaultValueString: this.__defaultValueString,
			defaultValueUri: this.__defaultValueUri,
			defaultValueDate: this.__defaultValueDate,
			defaultValueDateTime: this.__defaultValueDateTime,
			defaultValueTime: this.__defaultValueTime,
			defaultValueCode: this.__defaultValueCode,
			defaultValueOid: this.__defaultValueOid,
			defaultValueId: this.__defaultValueId,
			defaultValueUnsignedInt: this.__defaultValueUnsignedInt,
			defaultValuePositiveInt: this.__defaultValuePositiveInt,
			defaultValueMarkdown: this.__defaultValueMarkdown,
			defaultValueAnnotation: this.__defaultValueAnnotation && this.__defaultValueAnnotation.toJSON(),
			defaultValueAttachment: this.__defaultValueAttachment && this.__defaultValueAttachment.toJSON(),
			defaultValueIdentifier: this.__defaultValueIdentifier && this.__defaultValueIdentifier.toJSON(),
			defaultValueCodeableConcept: this.__defaultValueCodeableConcept && this.__defaultValueCodeableConcept.toJSON(),
			defaultValueCoding: this.__defaultValueCoding && this.__defaultValueCoding.toJSON(),
			defaultValueQuantity: this.__defaultValueQuantity && this.__defaultValueQuantity.toJSON(),
			defaultValueRange: this.__defaultValueRange && this.__defaultValueRange.toJSON(),
			defaultValuePeriod: this.__defaultValuePeriod && this.__defaultValuePeriod.toJSON(),
			defaultValueRatio: this.__defaultValueRatio && this.__defaultValueRatio.toJSON(),
			defaultValueSampledData: this.__defaultValueSampledData && this.__defaultValueSampledData.toJSON(),
			defaultValueSignature: this.__defaultValueSignature && this.__defaultValueSignature.toJSON(),
			defaultValueHumanName: this.__defaultValueHumanName && this.__defaultValueHumanName.toJSON(),
			defaultValueAddress: this.__defaultValueAddress && this.__defaultValueAddress.toJSON(),
			defaultValueContactPoint: this.__defaultValueContactPoint && this.__defaultValueContactPoint.toJSON(),
			defaultValueTiming: this.__defaultValueTiming && this.__defaultValueTiming.toJSON(),
			defaultValueReference: this.__defaultValueReference && this.__defaultValueReference.toJSON(),
			defaultValueMeta: this.__defaultValueMeta && this.__defaultValueMeta.toJSON(),
			meaningWhenMissing: this.__meaningWhenMissing,
			fixedBoolean: this.__fixedBoolean,
			fixedInteger: this.__fixedInteger,
			fixedDecimal: this.__fixedDecimal,
			fixedBase64Binary: this.__fixedBase64Binary,
			fixedInstant: this.__fixedInstant,
			fixedString: this.__fixedString,
			fixedUri: this.__fixedUri,
			fixedDate: this.__fixedDate,
			fixedDateTime: this.__fixedDateTime,
			fixedTime: this.__fixedTime,
			fixedCode: this.__fixedCode,
			fixedOid: this.__fixedOid,
			fixedId: this.__fixedId,
			fixedUnsignedInt: this.__fixedUnsignedInt,
			fixedPositiveInt: this.__fixedPositiveInt,
			fixedMarkdown: this.__fixedMarkdown,
			fixedAnnotation: this.__fixedAnnotation && this.__fixedAnnotation.toJSON(),
			fixedAttachment: this.__fixedAttachment && this.__fixedAttachment.toJSON(),
			fixedIdentifier: this.__fixedIdentifier && this.__fixedIdentifier.toJSON(),
			fixedCodeableConcept: this.__fixedCodeableConcept && this.__fixedCodeableConcept.toJSON(),
			fixedCoding: this.__fixedCoding && this.__fixedCoding.toJSON(),
			fixedQuantity: this.__fixedQuantity && this.__fixedQuantity.toJSON(),
			fixedRange: this.__fixedRange && this.__fixedRange.toJSON(),
			fixedPeriod: this.__fixedPeriod && this.__fixedPeriod.toJSON(),
			fixedRatio: this.__fixedRatio && this.__fixedRatio.toJSON(),
			fixedSampledData: this.__fixedSampledData && this.__fixedSampledData.toJSON(),
			fixedSignature: this.__fixedSignature && this.__fixedSignature.toJSON(),
			fixedHumanName: this.__fixedHumanName && this.__fixedHumanName.toJSON(),
			fixedAddress: this.__fixedAddress && this.__fixedAddress.toJSON(),
			fixedContactPoint: this.__fixedContactPoint && this.__fixedContactPoint.toJSON(),
			fixedTiming: this.__fixedTiming && this.__fixedTiming.toJSON(),
			fixedReference: this.__fixedReference && this.__fixedReference.toJSON(),
			fixedMeta: this.__fixedMeta && this.__fixedMeta.toJSON(),
			patternBoolean: this.__patternBoolean,
			patternInteger: this.__patternInteger,
			patternDecimal: this.__patternDecimal,
			patternBase64Binary: this.__patternBase64Binary,
			patternInstant: this.__patternInstant,
			patternString: this.__patternString,
			patternUri: this.__patternUri,
			patternDate: this.__patternDate,
			patternDateTime: this.__patternDateTime,
			patternTime: this.__patternTime,
			patternCode: this.__patternCode,
			patternOid: this.__patternOid,
			patternId: this.__patternId,
			patternUnsignedInt: this.__patternUnsignedInt,
			patternPositiveInt: this.__patternPositiveInt,
			patternMarkdown: this.__patternMarkdown,
			patternAnnotation: this.__patternAnnotation && this.__patternAnnotation.toJSON(),
			patternAttachment: this.__patternAttachment && this.__patternAttachment.toJSON(),
			patternIdentifier: this.__patternIdentifier && this.__patternIdentifier.toJSON(),
			patternCodeableConcept: this.__patternCodeableConcept && this.__patternCodeableConcept.toJSON(),
			patternCoding: this.__patternCoding && this.__patternCoding.toJSON(),
			patternQuantity: this.__patternQuantity && this.__patternQuantity.toJSON(),
			patternRange: this.__patternRange && this.__patternRange.toJSON(),
			patternPeriod: this.__patternPeriod && this.__patternPeriod.toJSON(),
			patternRatio: this.__patternRatio && this.__patternRatio.toJSON(),
			patternSampledData: this.__patternSampledData && this.__patternSampledData.toJSON(),
			patternSignature: this.__patternSignature && this.__patternSignature.toJSON(),
			patternHumanName: this.__patternHumanName && this.__patternHumanName.toJSON(),
			patternAddress: this.__patternAddress && this.__patternAddress.toJSON(),
			patternContactPoint: this.__patternContactPoint && this.__patternContactPoint.toJSON(),
			patternTiming: this.__patternTiming && this.__patternTiming.toJSON(),
			patternReference: this.__patternReference && this.__patternReference.toJSON(),
			patternMeta: this.__patternMeta && this.__patternMeta.toJSON(),
			exampleBoolean: this.__exampleBoolean,
			exampleInteger: this.__exampleInteger,
			exampleDecimal: this.__exampleDecimal,
			exampleBase64Binary: this.__exampleBase64Binary,
			exampleInstant: this.__exampleInstant,
			exampleString: this.__exampleString,
			exampleUri: this.__exampleUri,
			exampleDate: this.__exampleDate,
			exampleDateTime: this.__exampleDateTime,
			exampleTime: this.__exampleTime,
			exampleCode: this.__exampleCode,
			exampleOid: this.__exampleOid,
			exampleId: this.__exampleId,
			exampleUnsignedInt: this.__exampleUnsignedInt,
			examplePositiveInt: this.__examplePositiveInt,
			exampleMarkdown: this.__exampleMarkdown,
			exampleAnnotation: this.__exampleAnnotation && this.__exampleAnnotation.toJSON(),
			exampleAttachment: this.__exampleAttachment && this.__exampleAttachment.toJSON(),
			exampleIdentifier: this.__exampleIdentifier && this.__exampleIdentifier.toJSON(),
			exampleCodeableConcept: this.__exampleCodeableConcept && this.__exampleCodeableConcept.toJSON(),
			exampleCoding: this.__exampleCoding && this.__exampleCoding.toJSON(),
			exampleQuantity: this.__exampleQuantity && this.__exampleQuantity.toJSON(),
			exampleRange: this.__exampleRange && this.__exampleRange.toJSON(),
			examplePeriod: this.__examplePeriod && this.__examplePeriod.toJSON(),
			exampleRatio: this.__exampleRatio && this.__exampleRatio.toJSON(),
			exampleSampledData: this.__exampleSampledData && this.__exampleSampledData.toJSON(),
			exampleSignature: this.__exampleSignature && this.__exampleSignature.toJSON(),
			exampleHumanName: this.__exampleHumanName && this.__exampleHumanName.toJSON(),
			exampleAddress: this.__exampleAddress && this.__exampleAddress.toJSON(),
			exampleContactPoint: this.__exampleContactPoint && this.__exampleContactPoint.toJSON(),
			exampleTiming: this.__exampleTiming && this.__exampleTiming.toJSON(),
			exampleReference: this.__exampleReference && this.__exampleReference.toJSON(),
			exampleMeta: this.__exampleMeta && this.__exampleMeta.toJSON(),
			minValueBoolean: this.__minValueBoolean,
			minValueInteger: this.__minValueInteger,
			minValueDecimal: this.__minValueDecimal,
			minValueBase64Binary: this.__minValueBase64Binary,
			minValueInstant: this.__minValueInstant,
			minValueString: this.__minValueString,
			minValueUri: this.__minValueUri,
			minValueDate: this.__minValueDate,
			minValueDateTime: this.__minValueDateTime,
			minValueTime: this.__minValueTime,
			minValueCode: this.__minValueCode,
			minValueOid: this.__minValueOid,
			minValueId: this.__minValueId,
			minValueUnsignedInt: this.__minValueUnsignedInt,
			minValuePositiveInt: this.__minValuePositiveInt,
			minValueMarkdown: this.__minValueMarkdown,
			minValueAnnotation: this.__minValueAnnotation && this.__minValueAnnotation.toJSON(),
			minValueAttachment: this.__minValueAttachment && this.__minValueAttachment.toJSON(),
			minValueIdentifier: this.__minValueIdentifier && this.__minValueIdentifier.toJSON(),
			minValueCodeableConcept: this.__minValueCodeableConcept && this.__minValueCodeableConcept.toJSON(),
			minValueCoding: this.__minValueCoding && this.__minValueCoding.toJSON(),
			minValueQuantity: this.__minValueQuantity && this.__minValueQuantity.toJSON(),
			minValueRange: this.__minValueRange && this.__minValueRange.toJSON(),
			minValuePeriod: this.__minValuePeriod && this.__minValuePeriod.toJSON(),
			minValueRatio: this.__minValueRatio && this.__minValueRatio.toJSON(),
			minValueSampledData: this.__minValueSampledData && this.__minValueSampledData.toJSON(),
			minValueSignature: this.__minValueSignature && this.__minValueSignature.toJSON(),
			minValueHumanName: this.__minValueHumanName && this.__minValueHumanName.toJSON(),
			minValueAddress: this.__minValueAddress && this.__minValueAddress.toJSON(),
			minValueContactPoint: this.__minValueContactPoint && this.__minValueContactPoint.toJSON(),
			minValueTiming: this.__minValueTiming && this.__minValueTiming.toJSON(),
			minValueReference: this.__minValueReference && this.__minValueReference.toJSON(),
			minValueMeta: this.__minValueMeta && this.__minValueMeta.toJSON(),
			maxValueBoolean: this.__maxValueBoolean,
			maxValueInteger: this.__maxValueInteger,
			maxValueDecimal: this.__maxValueDecimal,
			maxValueBase64Binary: this.__maxValueBase64Binary,
			maxValueInstant: this.__maxValueInstant,
			maxValueString: this.__maxValueString,
			maxValueUri: this.__maxValueUri,
			maxValueDate: this.__maxValueDate,
			maxValueDateTime: this.__maxValueDateTime,
			maxValueTime: this.__maxValueTime,
			maxValueCode: this.__maxValueCode,
			maxValueOid: this.__maxValueOid,
			maxValueId: this.__maxValueId,
			maxValueUnsignedInt: this.__maxValueUnsignedInt,
			maxValuePositiveInt: this.__maxValuePositiveInt,
			maxValueMarkdown: this.__maxValueMarkdown,
			maxValueAnnotation: this.__maxValueAnnotation && this.__maxValueAnnotation.toJSON(),
			maxValueAttachment: this.__maxValueAttachment && this.__maxValueAttachment.toJSON(),
			maxValueIdentifier: this.__maxValueIdentifier && this.__maxValueIdentifier.toJSON(),
			maxValueCodeableConcept: this.__maxValueCodeableConcept && this.__maxValueCodeableConcept.toJSON(),
			maxValueCoding: this.__maxValueCoding && this.__maxValueCoding.toJSON(),
			maxValueQuantity: this.__maxValueQuantity && this.__maxValueQuantity.toJSON(),
			maxValueRange: this.__maxValueRange && this.__maxValueRange.toJSON(),
			maxValuePeriod: this.__maxValuePeriod && this.__maxValuePeriod.toJSON(),
			maxValueRatio: this.__maxValueRatio && this.__maxValueRatio.toJSON(),
			maxValueSampledData: this.__maxValueSampledData && this.__maxValueSampledData.toJSON(),
			maxValueSignature: this.__maxValueSignature && this.__maxValueSignature.toJSON(),
			maxValueHumanName: this.__maxValueHumanName && this.__maxValueHumanName.toJSON(),
			maxValueAddress: this.__maxValueAddress && this.__maxValueAddress.toJSON(),
			maxValueContactPoint: this.__maxValueContactPoint && this.__maxValueContactPoint.toJSON(),
			maxValueTiming: this.__maxValueTiming && this.__maxValueTiming.toJSON(),
			maxValueReference: this.__maxValueReference && this.__maxValueReference.toJSON(),
			maxValueMeta: this.__maxValueMeta && this.__maxValueMeta.toJSON(),
			maxLength: this.__maxLength,
			condition: this.__condition,
			constraint: this.__constraint && this.__constraint.map(v => v.toJSON()),
			mustSupport: this.__mustSupport,
			isModifier: this.__isModifier,
			isSummary: this.__isSummary,
			binding: this.__binding && this.__binding.toJSON(),
			mapping: this.__mapping && this.__mapping.map(v => v.toJSON()),
		});
	}
}

module.exports = ElementDefinition;
